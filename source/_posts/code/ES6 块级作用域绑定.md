---
title: ES6 块级作用域绑定
categories:
  - Code
tags:
  - js
  - es6
abbrlink: 50949
date: 2017-07-16 15:05:58
updated: 2021-09-19 21:41:27
---

原因：var 声明和变量提升（Hoisting）机制。

## 块级声明

块级声明用于声明在指定块之外无法访问的变量

块级作用域（词法作用域）：

- 函数内部
- 块中{}

### let 声明（变量）

用 let 替代 var 来声明变量，可以把变量作用域限制在当前代码块中。由于 let 声明不会被提升，因此开发者通常使用 let 声明语句放在封闭代码块的顶部，一遍整个代码块都可以访问。

### 禁止重声明

同一作用域中不能用 let 重复定义已经存在的标识符，否则会抛出错误。但如果当前作用域内嵌另一个作用域，便可在内嵌作用域中用 let 声明同名变量。

### const 声明（常量）

- const 和 let 声明的都是块级标识符
- 其值一旦被设定都不可更改（不可再次赋值）
- 每个通过 const 声明的常量必须进行初始化（赋值）
- **和其他语言中常量不同的是：es6 中如果常量是对象，则对象中的值可以修改（修改对象的属性值）**

```js
const person = {
    name: "Nicholas"
}

// 可以修改对象属性的值
person.name = "Greg"

// 抛出语法错误
person = {
    name： "Greg"
}
```

修改绑定的值不会报错，但直接给 person 赋值，既修改 person 的绑定，会抛出错误。
**const 声明不允许修改绑定，但允许修改绑定的值**

### 临时死区（Temporal Dead Zone/TDZ）

- 临时死区（Temporal Dead Zone/TDZ），常被用来描述 let 和 const 的不提示效果
- 只有执行过变量声明语句后，变量才会从 TDZ 中移出，然后才能正常访问
- 但在 let 声明的作用域外对变量使用 typeof 则不会报错：

```js
console.log(typeof value); // "undefined"

if (condition) {
  let value = "blue";
}
```

typeof 是在声明变量 value 的代码块外执行的，此时 value 并不在 TDZ 中。也就意味着不存在 value 这个绑定，typeof 最终返回"undefined"

## 循环中的块作用域绑定

```js
for (let i = 0; i < 10; i++) {
  prosess(items[i]);
}

// i在这里不可访问，抛出错误
console.log(i);
```

### 循环中的函数

- 长久以来，var 声明让开发者在循环中创建函数变得异常困难，因为变量到了循环之外仍能访问。ES6 中 let 和 const 提供的块级绑定让我们无需再这么折腾
- 开发者在循环中使用立即调用函数表达式（IIFE），以强制生成计数器变量的副本

### 循环中的 let 声明

- 每次循环的时候 let 声明都会创建一个新变量 i，并将其初始化为 i 的当前值
- **let 声明在循环内部的行为是标准中专门定义的，它不一定与 let 的不提升特性相关，理解这点至关重要**

### 循环中的 const 声明

- 对应 for 循环，可以在初始化变量时使用 const，但更改这个变量时就会抛出错误
- 在 for-in 和 for-of 循环中，因为在每次迭代不会修改已有绑定，而是创建一个新绑定，所以不会抛出错误

## 全局块作用域绑定

- 当 var 被用于全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的 window 对象）的属性
- 如果不想为全局对象创建属性，使用 let 和 const 则安全得多
- 如果希望在全局对象下定义变量，仍然可以使用 var。这种情况常见于在浏览器中跨 frame 或跨 window 访问

## 块级绑定最佳实践的进化

**新的理念：**
默认使用 const，只有确实需要改变变量的值时使用 let。因为大部分变量的值在初始化后不应再改变，而预料之外的变量值的改变是很多 bug 的源头。（某种程度上实现代码的不可变，从而防止某些错误的产生）。
